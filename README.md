# 如何做一道浙大C程理论考题

## 第一部分 选择题

>   若变量已正确定义，表达式` (j=3, j++) `的值是_____ 。(2000)(表达式求值)
> 
> A、3          
> 
> B、4           
> 
> C、5            
> 
> D、0

 正解：A  

 **对于逗号表达式，其整个表达式的值为最后一个表达式的值**，所以` (j=3, j++) `表达式的值最后就是j++的值。后置自增在表达式执行结束后生效。

>已知字符 ‘a’ 的ASCII码为 97 ，执行下列语句的输出是_____。(2000)(格式化输出)
> 
> `printf ("%d, %c", ’b’, ’b’+1 ) ;`
> 
> A、98, b        
> 
> B、语句不合法    
> 
> C、98, 99      
> 
> D、98, c

正解：D

格式控制字符串用于指定输出格式。%d输出字符常量'b'的ASCII码（比'a'大1即98），%c输出ASCII码对应字符常量（ASCII码比'b'大1即C）。

>表达式`strcmp(“box”, “boss”) `的值是一个_______。(2000)(字符串处理函数)
>
>A、正数
>
>B、负数
>
>C、 0
>
>D、 不确定的数

正解：A

`strcmp(*s1, *s2)`接受两个char类型的指针作为参数。比较时两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇'\0'为止。当s1<s2时返回负数；当s1=s2时，返回值= 0；当s1>s2时，返回正数。本题中'x'>'s'，所以返回一个正数。

>数组定义为 `int a[3][2]={1, 2, 3, 4, 5, 6}`，数组元素_____的值为6。(2000)(数组)
>
>A、a[3][2]
>
>B、a[2][1]
>
>C、a[1][2]
>
>D、a[2][3]

正解：B

C语言二维数组初始化时可以将列数溢出到下一行。注意数组下标引用时从0开始。所以值为6的元素在“第三行第二列”，即a[2][1]。

>判断i和j至少有一个值为非0的表达式是_____。(2000)(表达式求值)
>
>A、`i!=0 && j!=0`
>
>B、`i*j!=0`
>
>C、`!(i==0 || j==0)`
>
>D、`i&&j`

正解：B

A中关系运算符 != 优先级比逻辑运算符 && 优先级高，为真的条件是 i 和 j 均不等于0 ; B为真的条件是 i 和 j 之积不等于0，即 i 和 j 中至少有一个不等于0 ; C相当于 i 或 j 有一个等于0即为假，即要求 i 和 j 都不等于0 ; D为真的条件是 i 和 j 都不为 0 。

>若a是基本整型变量，c是单精度实型变量，输入语句______是错误的。(2000)(格式化输入)
>
>A、`scanf(”%d,%f”, &a, &c);`         
>
>B、`scanf(”d=%d, c=%f”, &a, &c);`
>
>C、`scanf(”%d%f”, &a, &c)`;           
>
>D、`scanf(”%d%f”, a, c);`

正解：D

D错在输入时没有在变量前加地址运算符`&`。

>若变量已正确定义并且指针p已经指向某个变量x，则(*p)++相当于_____。(2000)(指针)
>A、`p++`
>
>B、`x++`
>
>C、`*(p++)`
>
>D、`&x++`

正解：B

由于括号的存在`(*p)++`先对p解引用，后置自增的对象即为指针p指向的变量x。`p++`作用是使p中内容（一个地址）加1。`*(p++)`含义是p中存放的地址加1后的地址中存放的变量。`&x++`的作用是使地址为x的值的变量加1。

>下列程序段的输出是_____。(2000)(指针)
>```c
>int c[]={1, 3, 5};
>
>int *k=c+1;
>
>printf("%d", *++k);
>```
>A、3
>
>B、5
>
>C、4
>
>D、6

正解：B

```c
int *k=c+1;
```
将c[0]后一个元素的地址赋给了k。前置自增和解引用的优先级相同，结合性使从右往左，所以输出时`*++k`指向的是c[2]。

>不正确的赋值或赋初值的方式是______。(2000)(字符串数组)
>
>A、`char str[]="string"；`
>         
>B、`char str[7]={'s', 't', 'r', 'i', 'n', 'g'}；`
>
>C、`char str[10]；str="string"；`
>
>D、`char str[7]={'s', 't', 'r', 'i', 'n', 'g', ’\0’}；`

正解:B

ACD分别展示了三种给字符串数组的正确方式。当为已经完成定义的字符数组赋值时，不能采用类似于初始化的方式为字符数组赋值了。错误的原因是字符数组名代表字符数组的收地址，不可修改，不能作为左值。

>对于以下结构定义，++p->str中的++加在_____。(2000)(指针)
>```c
>	struct { 
>       int len; 
>	    char *str;
>	} *p;
>```
>A、指针str上
>
>B、指针p上
>       
>C、str指的内容上   
>
>D、以上均不是

正解:A

成员选择(指针)运算符的优先级比自增运算符高。该结构中的str是一个指针变量,自增加在指针str上。

>对于如下说明，语法和语义都正确的赋值是_____。(2000)(指针)
>```c
>	int c, *s, a[]={1, 3, 5};
>```
>A、`c=*s; `   
>     
>B、`s[0]=a[0]; `
>     
>C、`s=&a[1]; `   
>    
>D、`c=a;`

正解:C

A指针未初始化;B指针名后不能像数组一样加[ ];C使s的值为数组a第二个元素的地址,正确;D把数组首元素地址赋给变量c,语义不正确。

>表达式 `!(x>0||y>0)` 等价于_____。(2002)(表达式求值)
>
>A．`!(x>0)&&!(y>0)`
>
>B．`!x>0&&!y>0	`
>
>C．`!x>0||!y>0	`
>
>D．`!(x>0)||!(y>0)`

正解: A

表达式 `!(x>0||y>0)` 为真的条件是x, y都小于等于0。B为真的条件是(!x)和(!y)都大于0(!的优先级比&&高)，即x和y都等于0。C为真的条件是(!x)或(!y)大于0，即x或y等于0。D为真的条件是x或y小于等于0。

>若 x 是浮点型变量，表达式 (x=10/4) 的值是_____ 。(2002)(表达式求值)
>
>A．2.5
>
>B．2.0
>
>C．3
>
>D．2

正解：B

x是浮点型变量但(10/4)是整型除法小数部分截断。

>对于变量定义 `int a[10], *p=a;`，表达式______是不正确的。(2002)(指针)
>
>A．`a[9]`
>
>B．`p[5]`
>
>C．`*p++`
>
>D．`a++`

正解：D

语句`int a[10], *p=a;`将数组a首元素的地址赋给指针变量p。D错在数组a是指针常量，不是变量，所以像a=p、a++、a+=2这样的表达式都是非法的，不能改变指针常量的值。

>设程序中不再定义和声明变量，写出在函数fun中可以使用的所有变量______。(2002)(变量作用域)
>```c
>    #include <stdio.h>
>    void fun(int x)
>{  static int y;
>       ……
>       return;
>    }
>    int z;
>    void main( )
>    {   int a,b;
>        fun(a);
>        ……
>    }
>```
>A．x, y
>	
>B．x, y, z	
>
>C．a,b,y,z	
>
>D．a,b,x,y,z

正解：A

函数f可以使用其形参x和内部定义的静态变量y。全局变量z由于声明在f后所以f不能使用。a, b是main函数内部的变量f不能使用。

>对于变量定义 `int p[5], *a[5];`，表达式______是正确的。(2002)(指针)
>
>A．`p=a`	
>
>B．`p[0]=a `	
>
>C．`*(a+1)=p`
>
>D．`a[0]=2`

正解：C

`int p[5], *a[5];`定义了一个5个元素的数组p和5个元素的指针数组（[]优先级比*高）。A错在p是指针常量，不是变量，不能改变指针常量的值。B错在将一个指针常量的值（地址）赋给一个int型的数组元素。C将p首元素的地址赋给a中的第二个元素。D错在将一个值非0的常量赋给一个指针变量。


## 第二部分 程序阅读题

>写出下列程序段的输出结果。(2000)(宏)
>
>   ```c
>    #define  A  10
>    #define  B  (A<A+2)-2
>    printf("%d", B*2);
>   ```

正解：3

先将B代入：(A<A+2)-2\*2；再将A代入：(10<10+2)-2\*2。加运算符优先级高于小于运算符，`(10<10+2)-2\*2`=`(10<12)-4`=`1-4`=-3。

>写出下列程序段的输出结果。(2000)(循环条件)
>```c
>    int k, x;
>    for (k=0, x=0; k<=9&&x!=10; k++)
>       x+=2;
>    printf ("%d, %d", k, x) ;
> ```

正解：5, 10

k和x初值均为0；进入循环的条件k<=9且x不等于10；每次循环结束k加1。每次进入循环x加2。循环结束时x=10，循环5次k加1五次，k=5。

>对于以下递归函数f，调用 f (3) 的返回值是_____。(2000)(函数递归)
>```c
>    f (int n)
>    {   return ((n>0) ? 2*f(n-1)+f(n-2) : -1);  }
>```
正解：-17

语句`((n>0) ? 2*f(n-1)+f(n-2) : -1);`中优先级()最高，*次之，+次之，?:次之。所以n>0时返回`2*f(n-1)+f(n-2)`，否则返回-1。

f(3) = 2*f(2)+f(1)

f(2) = 2*f(1)+f(0)

f(1) = 2*f(0)+f(-1)

得f(1) = -3; f(2) = -7; f(3) = -17。

>写出下列程序段的输出结果。(2000)(字符串数组)
>```c
>    char str[]="hello\tworld\n";
>    printf("%d, %c\n", sizeof(str), *(str+10));
> ```

正解：13, d

\t和\n是转义字符，加上末尾\0字符串数组中共13个字符常量。`*(str+10)`指向的是str[10]，即'd'。

>下列程序段的输出结果是_____。(2002)(循环)  
>```c
>int k, s;
>	for(k=1, s=0; k<10; k++){
>	    if (k%2==0) continue; 
>         s += k; 
>   }
>printf("k=%d s=%d", k, s);
>```

正解：k=10 s=25

k的初值为1，s的初值为0。k<10则进入循环。进入循环后判断k是否能被2整除，是则跳过循环剩余部分，否则s的值增加k。
每一轮循环后k和s的值分别为：

| 循环轮数 | k值 | s值 |
| :----: | :----: | :----: |
| 1 | 2 | 1 |
| 2 | 3 | 1 |
| 3 | 4 | 4 |
| 4 | 5 | 4 |
| 5 | 6 | 9 |
| 6 | 7 | 9 |
| 7 | 8 | 16 |
| 8 | 9 | 16 |
| 9 | 10 | 25 |

>下列程序段的输出结果是_____。(2002)(宏)  
>```c
>    #define MM(x,y)   (x*y)
>    printf("%d", MM(2+3,15));
>```

正解：47

MM(2+3,15)替换后为2+3*15=47。

>下列程序段的输出结果是_____。(2002)(switch)
>```c  
>int k=1, s=0;
>switch (k) {
>      case 1: s+=10; 
>      case 2: s+=20; break;
>      default: s+=3; 
>}
>printf("k=%d s=%d", k, s);
>```

正解：k=1 s=30

因为k=1，执行`s+=10`，此后s=10，接着执行`s+=20`，此后s=30，之后遇到`break;`跳出switch，输出。过程中k值无变化。

>下列程序的输出结果是_____。(2002)(静态变量)
>```c
># include <stdio.h>
>int f( )                      
>{   static int k; 
>     return ++k;
>}
>void main( )
>{  int k;
>    for(k=0;k<3;k++)
>      printf("%d#", f( ));
>}

正解：1#2#3#

注意k在函数f()中定义为静态变量，只进行一次初始化。

>下列程序段的输出结果是_____。(2002)(指针)
>```c 
>int k=1, j=2, *p, *q, *t; 
>p=&k; q=&j;
>t=p; p=q; q=t;
>printf("%d, %d",*p, k);
>```

正解：2, 1

`p=&k; q=&j;`将k的地址赋给p，将j的地址赋给q。`t=p; p=q; q=t;`交换p和q的内容，于是p此时指向j，而k的值并未改变。

>下列程序段的输出结果是_____。(2002)(数组)
>```c
>int c[ ]={10, 30, 5};
>int *pc;
>for(pc=c; pc<c+2; pc++)
>   printf("%d#", *pc);
>```

正解：10#30#

c是数组首元素的地址，循环进行了两轮。

>下列程序段的输出结果是_____。(2002)(指针数组)  
>```c
>char  *st[ ]={"ONE","TWO","FOUR","K"};
>printf("%s, %c\n", *(st+2), **st+1);

正解：FOUR, P

`char  *st[ ]={"ONE","TWO","FOUR","K"};`声明了一个指针数组st，每个元素是字符串首个字符的地址。`*(st+2)`即为数组st的第三个元素为地址开头的字符串。`**st+1`中*的优先级比+高，`*st`的值是"ONE"首个字符的地址，`**st`指向"O"，**st+1即为P。

>下列程序的输出结果是_____。(2002)(函数)
>```c
>#include <stdio.h>
>void p(int *x,int y)
>{  ++*x;
>   y=y+2;
>}
>void main()
>    {  int x=0, y=3;
>       p(&y, y);
>       printf("%d, %d", x, y);
>    }
>```

正解：0,4

`++*x`由于运算符的右结合性，先对指针解引用，再将指针指向变量加1。而`y=y+2`由于y是函数中的形参并不影响原函数中实参的值。x的值同理不改变。

>下列程序的输出结果是_______。(2002)(循环)
>```c
>    #include <stdio.h>
>    void main( )
>    {
>        int k, x, s, t;
>
>        x=3;
>        s=0; t=x;
>        for(k=1; k<=3; k++){
>            t=t*10+x;
>            s=s+t; 
>           printf("%d#", s);
>        }
>    }
> ```    

正解：33#366#3699#

| 循环轮数 | s值 | t值 |
| :----: | :----: | :----: |
| 进入前 | 0 | 3 |
| 1 | 33 | 33 |
| 2 | 366 | 333 |
| 3 | 3699 | 3333 |

>输入3  9 8 6 5 3 7 1 2 4  2  1 2 3 4<回车>后，下列程序的输出结果是_______。(2002)
>```c
>#include "stdio.h"
>void main( )
>{  
>	  int flag,i,j,k,col,n,ri,a[6][6];
>       for(ri=1; ri<=2; ri++){
>          scanf("%d",&n);
>          for(i=0; i<n; i++)
>             for(j=0; j<n; j++)
>                  scanf("%d",&a[i][j]);
>          flag=0;
>          for(i=0; i<n; i++){
>	         col=0;
>              for(j=0; j<n; j++)
>	              if (a[i][col]<a[i][j])  col=j;
>              for (k=0; k<n; k++)
>	              if(a[i][col]<a[k][col])   break;
>	         if(k>=n){
>			      printf("a[%d][%d]=%d#", i, col,a[i][col]);
>                  flag=1;
>		     }
>          }
>          if(!flag)  printf("NO#");
>       }
>}
>```

正解：a[0][0]=9#a[1][2]=7#a[1][1]=4

```c
scanf("%d",&n);
for(i=0; i<n; i++)
    for(j=0; j<n; j++)
        scanf("%d",&a[i][j]);
```
读取n，再读取n行n列的矩阵，本题中第一个矩阵为

9 8 6

5 3 7

1 2 4

第二个矩阵为

1 2

3 4

```c
for(i=0; i<n; i++){
	col=0;
    for(j=0; j<n; j++)
	    if (a[i][col]<a[i][j])  col=j;//找到最大元素所在行
        for (k=0; k<n; k++)
	        if(a[i][col]<a[k][col])   break;//再在该行查找是否有比该元素更大的数，有则跳出循环
	        if(k>=n){//如果没有找到那么这个元素在其所在行和所在列都是最大的，输出
			    printf("a[%d][%d]=%d#", i, col,a[i][col]);
                flag=1;
		     }
```
这一部分的作用见注释。

>输入how are you?<回车>后，下列程序的输出结果是_______。(2002)
>```c
>#include <stdio.h>
>void main( )
>{
>    int word;
>		char ch;
>        
>    word=0;
>		while((ch=getchar())!='?'){
>			if(ch==' ') word=0;
>			else if(word==0){
>				word=1;
>				if(ch<='z'&&ch>='a')
>					ch=ch-'a'+'A';
>			}
>			putchar(ch);
>		}
>}
>```

正解：How Are You

程序的作用是将输入的字符串中每个单词的首字母（如果为小写）转换为大写。各部分作用见注释。

```c
#include <stdio.h>
void main( )
{
    int word;
	char ch;
        
    word=0;
	while((ch=getchar())!='?'){//读入字符到ch中，如果不是'?'则进入循环
		if(ch==' ') word=0;//读入空格时将word置0
		else if(word==0){//读入的不是空格且之前无空格外字符（即该字母为单词首字母）
				word=1;
				if(ch<='z'&&ch>='a')//判断该字符是否为小写字母
					ch=ch-'a'+'A';//将小写转换为大写
		}
		putchar(ch);
		}
}
```

>假设文本文件a.txt中存放了下列数据：
>
>one?two?1234?output?
>
>文本文件b.txt中存放了下列数据：
>
>one?two?1204?input?
>
>下列程序的输出结果是_______。(2002)(文件)
>```c
># include <stdio.h>
># include <stdlib.h>
>void main()
>{   int count;
>	 char ch1,ch2;
>    FILE *f1, *f2;
>
>	 if ((f1 = fopen("a.txt","r")) == NULL){
>         printf("Can't open file : %s\n", "a.txt");
>		exit(0);
>		}
>	 if ((f2 = fopen("b.txt","r")) == NULL){
>         printf("Can't open file : %s\n", "b.txt");
>		exit(0);
>		}
>	    count=0;
>	 while (!feof(f1)||!feof(f2)){
>         ch1=fgetc(f1);
>	    ch2=fgetc(f2);
>	    if(ch1!=ch2){
>           printf("%c#%c#",ch1,ch2);
>	      printf("%d#", count);
>	      break;
>	      }
>	      if(ch1=='?') count++;
>	    }
>	    fclose(f1);
>	    fclose(f2);
>}
>```
程序的作用是逐个两文件（如果均能打开）中的字符，输出第一对不同的字符及至此读取到几个'?'。其中比较部分程序段作用见注释。
```c
	while (!feof(f1)||!feof(f2)){//当设置了与流关联的文件结束标识符时，feof()返回一个非零值，否则返回零。f1或f2没到结尾即进入循环
       ch1=fgetc(f1);//fgetc()从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动
	   ch2=fgetc(f2);
	   if(ch1!=ch2){
          printf("%c#%c#",ch1,ch2);
	      printf("%d#", count);
	      break;//该对字符不相同时跳出while循环
	   }
	   if(ch1=='?') count++;
	}
```
