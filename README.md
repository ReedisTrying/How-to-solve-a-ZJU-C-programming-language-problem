# 如何做一道浙大C程理论考题

## 第一部分 选择题
>   若变量已正确定义，表达式` (j=3, j++) `的值是_____ 。(2000)(表达式求值)
> 
> A、3          
> 
> B、4           
> 
> C、5            
> 
> D、0

 正解：A  

 **对于逗号表达式，其整个表达式的值为最后一个表达式的值**，所以` (j=3, j++) `表达式的值最后就是j++的值。后置自增在表达式执行结束后生效。

>已知字符 ‘a’ 的ASCII码为 97 ，执行下列语句的输出是_____。(2000)(格式化输出)
> 
> `printf ("%d, %c", ’b’, ’b’+1 ) ;`
> 
> A、98, b        
> 
> B、语句不合法    
> 
> C、98, 99      
> 
> D、98, c

正解：D

格式控制字符串用于指定输出格式。%d输出字符常量'b'的ASCII码（比'a'大1即98），%c输出ASCII码对应字符常量（ASCII码比'b'大1即C）。

>表达式`strcmp(“box”, “boss”) `的值是一个_______。(2000)(字符串处理函数)
>
>A、正数
>
>B、负数
>
>C、 0
>
>D、 不确定的数

正解：A

`strcmp(*s1, *s2)`接受两个char类型的指针作为参数。比较时两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇'\0'为止。当s1<s2时返回负数；当s1=s2时，返回值= 0；当s1>s2时，返回正数。本题中'x'>'s'，所以返回一个正数。

>数组定义为 `int a[3][2]={1, 2, 3, 4, 5, 6}`，数组元素_____的值为6。(2000)(数组)
>
>A、a[3][2]
>
>B、a[2][1]
>
>C、a[1][2]
>
>D、a[2][3]

正解：B

C语言二维数组初始化时可以将列数溢出到下一行。注意数组下标引用时从0开始。所以值为6的元素在“第三行第二列”，即a[2][1]。

>判断i和j至少有一个值为非0的表达式是_____。(2000)(表达式求值)
>
>A、`i!=0 && j!=0`
>
>B、`i*j!=0`
>
>C、`!(i==0 || j==0)`
>
>D、`i&&j`

正解：B

A中关系运算符 != 优先级比逻辑运算符 && 优先级高，为真的条件是 i 和 j 均不等于0 ; B为真的条件是 i 和 j 之积不等于0，即 i 和 j 中至少有一个不等于0 ; C相当于 i 或 j 有一个等于0即为假，即要求 i 和 j 都不等于0 ; D为真的条件是 i 和 j 都不为 0 。

>若a是基本整型变量，c是单精度实型变量，输入语句______是错误的。(2000)(格式化输入)
>
>A、`scanf(”%d,%f”, &a, &c);`         
>
>B、`scanf(”d=%d, c=%f”, &a, &c);`
>
>C、`scanf(”%d%f”, &a, &c)`;           
>
>D、`scanf(”%d%f”, a, c);`

正解：D

D错在输入时没有在变量前加地址运算符`&`。

>若变量已正确定义并且指针p已经指向某个变量x，则(*p)++相当于_____。(2000)(指针)
>A、`p++`
>
>B、`x++`
>
>C、`*(p++)`
>
>D、`&x++`

正解：B

由于括号的存在`(*p)++`先对p解引用，后置自增的对象即为指针p指向的变量x。`p++`作用是使p中内容（一个地址）加1。`*(p++)`含义是p中存放的地址加1后的地址中存放的变量。`&x++`的作用是使地址为x的值的变量加1。

>下列程序段的输出是_____。(2000)(指针)
>```c
>int c[]={1, 3, 5};
>
>int *k=c+1;
>
>printf("%d", *++k);
>```
>A、3
>
>B、5
>
>C、4
>
>D、6

正解：B

```c
int *k=c+1;
```
将c[0]后一个元素的地址赋给了k。前置自增和解引用的优先级相同，结合性使从右往左，所以输出时`*++k`指向的是c[2]。

>不正确的赋值或赋初值的方式是______。(2000)(字符串数组)
>
>A、`char str[]="string"；`
>         
>B、`char str[7]={'s', 't', 'r', 'i', 'n', 'g'}；`
>
>C、`char str[10]；str="string"；`
>
>D、`char str[7]={'s', 't', 'r', 'i', 'n', 'g', ’\0’}；`

正解:B

ACD分别展示了三种给字符串数组的正确方式。当为已经完成定义的字符数组赋值时，不能采用类似于初始化的方式为字符数组赋值了。错误的原因是字符数组名代表字符数组的收地址，不可修改，不能作为左值。

>对于以下结构定义，++p->str中的++加在_____。(2000)(指针)
>```c
>	struct { 
>       int len; 
>	    char *str;
>	} *p;
>```
>A、指针str上
>
>B、指针p上
>       
>C、str指的内容上   
>
>D、以上均不是

正解:A

成员选择(指针)运算符的优先级比自增运算符高。该结构中的str是一个指针变量,自增加在指针str上。

>对于如下说明，语法和语义都正确的赋值是_____。(2000)(指针)
>```c
>	int c, *s, a[]={1, 3, 5};
>```
>A、`c=*s; `   
>     
>B、`s[0]=a[0]; `
>     
>C、`s=&a[1]; `   
>    
>D、`c=a;`

正解:C

A指针未初始化;B指针名后不能像数组一样加[ ];C使s的值为数组a第二个元素的地址,正确;D把数组首元素地址赋给变量c,语义不正确。

## 第二部分 程序阅读题

>写出下列程序段的输出结果。(2000)(宏)
>
>   ```c
>    #define  A  10
>    #define  B  (A<A+2)-2
>    printf("%d", B*2);
>   ```

正解：3

先将B代入：(A<A+2)-2\*2；再将A代入：(10<10+2)-2\*2。加运算符优先级高于小于运算符，`(10<10+2)-2\*2`=`(10<12)-4`=`1-4`=-3。

>写出下列程序段的输出结果。(2000)(循环条件)
>```c
>    int k, x;
>    for (k=0, x=0; k<=9&&x!=10; k++)
>       x+=2;
>    printf ("%d, %d", k, x) ;
> ```

正解：5, 10

k和x初值均为0；进入循环的条件k<=9且x不等于10；每次循环结束k加1。每次进入循环x加2。循环结束时x=10，循环5次k加1五次，k=5。

>对于以下递归函数f，调用 f (3) 的返回值是_____。(2000)(函数递归)
>```c
>    f (int n)
>    {   return ((n>0) ? 2*f(n-1)+f(n-2) : -1);  }
>```
正解：-17

语句`((n>0) ? 2*f(n-1)+f(n-2) : -1);`中优先级()最高，*次之，+次之，?:次之。所以n>0时返回`2*f(n-1)+f(n-2)`，否则返回-1。

f(3) = 2*f(2)+f(1)

f(2) = 2*f(1)+f(0)

f(1) = 2*f(0)+f(-1)

得f(1) = -3; f(2) = -7; f(3) = -17。

>写出下列程序段的输出结果。(2000)(字符串数组)
>```c
>    char str[]="hello\tworld\n";
>    printf("%d, %c\n", sizeof(str), *(str+10));
> ```

正解：13, d

\t和\n是转义字符，加上末尾\0字符串数组中共13个字符常量。`*(str+10)`指向的是str[10]，即'd'。
